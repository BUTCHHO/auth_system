import pytest
from auth.registration import Registrator
from auth.pydantic_models import User
from auth.exceptions import UserAlreadyExists

def get_mocks(mocker):
    user_actor = mocker.AsyncMock()
    user_reader = mocker.AsyncMock()
    hasher = mocker.Mock()
    return user_actor, user_reader, hasher

@pytest.mark.asyncio
async def test_registrate_user_success(mocker):
    user = User(name='tester', password='password')
    user_actor, user_reader, hasher = get_mocks(mocker)
    user_reader.get_record_by.return_value = None
    hasher.make_hash.return_value = 'super_long_hash'
    registrator = Registrator(user_actor, user_reader, hasher)
    result = await registrator.registrate_user(user)
    assert result is True

@pytest.mark.asyncio
async def test_registrate_user_already_exists(mocker):
    user = User(name='tester_who_already_exists', password='123')
    user_actor, user_reader, hasher = get_mocks(mocker)
    user_reader.get_record_by.return_value = 'not none'
    registrator = Registrator(user_actor, user_reader, hasher)
    with pytest.raises(UserAlreadyExists):
        await registrator.registrate_user(user)import pytest
import asyncio

from auth.pydantic_models import User
from auth.authentication import Authenticator


def get_mocks(mocker):
    user_getter = mocker.AsyncMock()
    hasher = mocker.Mock()
    session_maker = mocker.AsyncMock()
    session_reader = mocker.AsyncMock()
    cacher = mocker.Mock()
    return user_getter, hasher, session_maker, session_reader, cacher


@pytest.mark.asyncio
async def test_auth_by_name_and_psw_and_return_session_success(mocker):
    user = User(id=333, name='tester', password='super_long_hash')
    user_getter, hasher, session_maker, session_reader, cacher = get_mocks(mocker)
    user_getter.get_by_name.return_value = user
    hasher.compare_password_hashes.return_value = True
    session_maker.make_session_and_save.return_value = True
    authenticator = Authenticator(user_getter, hasher, session_maker, session_reader, cacher)
    result = await authenticator.auth_by_name_and_psw_and_return_session(user.name, user.password)
    assert result is True
from .exceptions import UserDontExists, SessionDontExists, SesssionExpired


class UserGetter:
    def __init__(self, user_reader, session_reader, cacher, time_handler):
        self.user_reader = user_reader
        self.session_reader = session_reader
        self.cacher = cacher
        self.time_handler = time_handler

    async def get_by_session_id(self, session_id):
        user_id = self.cacher.get_data(session_id)
        if user_id is not None:
            return self.get_user_if_in_cache(user_id)
        session = self.session_reader.get_by_kwargs(id=session_id)
        await self._raise_and_delete_session_if_invalid(session)
        user = await self.user_reader.get_by_kwargs(session_id=session_id)
        if not user:
            raise UserDontExists(user_id)
        return user

    async def get_user_if_in_cache(self, user_id):
        user = await self.user_reader.get_by_kwargs(id=user_id)
        if not user:
            raise UserDontExists(user_id)
        return user

    async def _raise_and_delete_session_if_invalid(self, session):
        if not session:
            raise SessionDontExists
        if not self.time_handler.is_date_future(session.expire_date):
            self.cacher.delete_data(session.id)
            await self.session_reader.delete_by_kwargs(id=session.id)
            raise SesssionExpired(session.id)

    async def get_by_name(self, name):
        user = await self.user_reader.get_by_kwargs(name=name)
        if not user:
            raise UserDontExists()
        return userfrom pydantic import BaseModel

class User(BaseModel):
    id: int | None = None
    name: str
    password: str

from .exceptions import InvalidPassword, UserDontExists


class Authenticator:
    def __init__(self, user_getter, hasher, session_maker, session_reader, cacher):
        self.user_getter = user_getter
        self.hasher = hasher
        self.session_maker = session_maker
        self.session_reader = session_reader
        self.cacher = cacher

    async def auth_by_session_id(self, session_id):
        return await self.user_getter.get_by_session_id(session_id)


    async def auth_by_name_and_psw_and_return_session(self, name, psw):
        user = await self.user_getter.get_by_name(name)
        if user is None:
            raise UserDontExists
        if not self.hasher.compare_password_hashes(psw, user.password):
            raise InvalidPassword
        session = await self.session_maker.make_session_and_save(user.id)
        return sessionfrom .exceptions import SessionDontExists


class Logouter:
    def __init__(self, user_reader, session_reader, session_actor, cacher):
        self.user_reader = user_reader
        self.session_reader = session_reader
        self.session_actor = session_actor
        self.cacher = cacher

    async def delete_session_for_user(self, user_id):
        """
        :raises: SessionDontExists
        """
        session = await self.session_reader.get_by_kwargs(user_id=user_id)
        if session is None:
            raise SessionDontExists
        await self.session_actor.delete_record_by_kwargs(id=session.id)
        self.cacher.delete_data(session.id)class SessionMaker:
    def __init__(self, session_reader, session_actor, time_handler, hasher, cacher, SESSION_EXPIRE_DAYS):
        self.session_reader = session_reader
        self.session_actor = session_actor
        self.hasher = hasher
        self.cacher = cacher
        self.time_handler = time_handler
        self.SESSION_EXPIRE_DAYS = SESSION_EXPIRE_DAYS

    async def _delete_session_if_already_exists(self, user_id):
        if session := await self.session_reader.get_by_kwargs(user_id=user_id):
            self.cacher.delete_data(session.id)
            await self.session_actor.delete_record_by_kwargs(user_id=user_id)

    def _make_session_obj(self):
        session_id = self.hasher.make_urlsafe_hash()
        session_expire_date = self.time_handler.add_days_to_current_date(self.SESSION_EXPIRE_DAYS)
        return self.session_actor.create_record(id=session_id, user_id=session_id, expire_date=session_expire_date)

    async def make_session_and_save(self, user_id):
        await self._delete_session_if_already_exists(user_id)
        session = self._make_session_obj()
        await self.session_actor.write_record_to_db(session)
        self.cacher.put_data(session.id, user_id)
        return session
from .pydantic_models import User
from .exceptions import UserAlreadyExists

class Registrator:
    def __init__(self, user_actor, user_reader, hash_maker):
        self.user_actor = user_actor
        self.user_reader = user_reader
        self.hash_maker = hash_maker

    async def registrate_user(self, user_model: User):
        if await self.user_reader.get_record_by(name=user_model.name):
            raise UserAlreadyExists
        hash_psw = self.hash_maker.make_hash(user_model.password)
        await self.user_actor.make_record_and_write(name=user_model.name, password=hash_psw)
        return Trueclass UserAlreadyExists(Exception):
    def __init__(self, name=''):
        msg = f'User {name} already exists'
        super().__init__(msg)

class UserDontExists(Exception):
    def __init__(self, id=None):
        msg = f'User with id {id} dont exists'
        super().__init__(msg)

class InvalidPassword(Exception):
    def __init__(self, password=None):
        msg = f'Wrong password {password}'
        super().__init__(msg)

class UserAlreadyHaveSession(Exception):
    def __init__(self, user_id=None):
        msg = f'User {user_id} already have session'
        super().__init__(msg)

class SessionDontExists(Exception):
    def __init__(self, user_id=None):
        msg = f'Session for user {user_id} dont exists'
        super().__init__(msg)

class SesssionExpired(Exception):
    def __init__(self, ses_id=None):
        msg = f'Session {ses_id} dont exists'
        super().__init__(msg)